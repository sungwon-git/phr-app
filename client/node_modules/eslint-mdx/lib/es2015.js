import path from 'path';
import remarkMdx from 'remark-mdx';
import remarkParse from 'remark-parse';
import unified from 'unified';

/// <reference path="../typings.d.ts" />
const FALLBACK_PARSERS = [
    '@typescript-eslint/parser',
    '@babel/eslint-parser',
    'babel-eslint',
    'espree',
];
const JSX_TYPES = ['JSXElement', 'JSXFragment'];
const isJsxNode = (node) => JSX_TYPES.includes(node.type);
// eslint-disable-next-line sonarjs/cognitive-complexity
const normalizeParser = (parser) => {
    if (parser) {
        if (typeof parser === 'string') {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            parser = require(parser);
        }
        if (typeof parser === 'object') {
            parser =
                ('parseForESLint' in parser && parser.parseForESLint) ||
                    ('parse' in parser && parser.parse);
        }
        if (typeof parser !== 'function') {
            throw new TypeError(`Invalid custom parser for \`eslint-mdx\`: ${parser}`);
        }
        return [parser];
    }
    const parsers = [];
    // try to load FALLBACK_PARSERS automatically
    for (const fallback of FALLBACK_PARSERS) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            const fallbackParser = require(fallback);
            /* istanbul ignore next */
            const parserFn = 'parseForESLint' in fallbackParser
                ? // eslint-disable-next-line @typescript-eslint/unbound-method
                    fallbackParser.parseForESLint
                : // eslint-disable-next-line @typescript-eslint/unbound-method
                    fallbackParser.parse;
            /* istanbul ignore else */
            if (parserFn) {
                parsers.push(parserFn);
            }
        }
        catch (_a) { }
    }
    return parsers;
};
const normalizePosition = (loc) => {
    const start = loc.start.offset;
    const end = loc.end.offset;
    return {
        range: [start, end],
        loc,
        start,
        end,
    };
};
const hasProperties = (obj, properties) => typeof obj === 'object' &&
    obj &&
    properties.every(property => property in obj);
// fix #292
const getPositionAt = (code, offset) => {
    let currOffset = 0;
    const lines = code.split('\n');
    // eslint-disable-next-line unicorn/no-for-loop
    for (let index = 0; index < lines.length; index++) {
        const line = index + 1;
        const nextOffset = currOffset + lines[index].length;
        if (nextOffset >= offset) {
            return {
                line,
                column: offset - currOffset,
            };
        }
        currOffset = nextOffset + 1; // add a line break `\n` offset
    }
};
const restoreNodeLocation = (node, point) => {
    if (node && typeof node === 'object') {
        for (const value of Object.values(node)) {
            restoreNodeLocation(value, point);
        }
    }
    if (!hasProperties(node, ['loc', 'range'])) {
        return node;
    }
    let { loc: { start: startLoc, end: endLoc }, range: [start, end], } = node;
    const range = [(start += point.offset), (end += point.offset)];
    return Object.assign(node, {
        start,
        end,
        range,
        loc: {
            start: {
                line: point.line + startLoc.line,
                column: startLoc.column + (startLoc.line === 1 ? point.column : 0),
            },
            end: {
                line: point.line + endLoc.line,
                column: endLoc.column + (endLoc.line === 1 ? point.column : 0),
            },
        },
    });
};
const arrayify = (...args) => args.reduce((arr, curr) => {
    arr.push(...(Array.isArray(curr) ? curr : curr == null ? [] : [curr]));
    return arr;
}, []);
const first = (items) => items && items[0];
const last = (items) => items && items[items.length - 1];

// based on https://github.com/mdx-js/mdx/blob/master/packages/remark-mdx/tag.js
const dotAllPolyfill = '[\0-\uFFFF]';
const attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
const unquoted = '[^"\'=<>`\\u0000-\\u0020]+';
const singleQuoted = "'[^']*'";
const doubleQuoted = '"[^"]*"';
const jsProps = '{.*}'.replace('.', dotAllPolyfill);
const attributeValue = '(?:' +
    unquoted +
    '|' +
    singleQuoted +
    '|' +
    doubleQuoted +
    '|' +
    jsProps +
    ')';
const attribute = '(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)';
const openTag = '<[A-Za-z]*[A-Za-z0-9\\.\\-]*' + attribute + '*\\s*>';
const closeTag = '<\\s*\\/[A-Za-z]*[A-Za-z0-9\\.\\-]*\\s*>';
const selfClosingTag = '<[A-Za-z]*[A-Za-z0-9\\.\\-]*' + attribute + '*\\s*\\/?>';
const comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
const commentOpen = '(<!---*)';
const commentClose = '(-*-->)';
const commentContent = `${commentOpen}([\\s\\S]*?)${commentClose}`;
const OPEN_TAG_REGEX = new RegExp(`^(?:${openTag})$`);
const CLOSE_TAG_REGEX = new RegExp(`^(?:${closeTag})$`);
const OPEN_CLOSE_TAG_REGEX = new RegExp(`^(?:${openTag + '[^<]*' + closeTag})$`);
const SELF_CLOSING_TAG_REGEX = new RegExp(`^(?:${selfClosingTag})$`);
const COMMENT_REGEX = new RegExp(`^(?:${comment})$`);
const COMMENT_CONTENT_REGEX = new RegExp(commentContent);
const COMMENT_CONTENT_REGEX_GLOBAL = new RegExp(commentContent, 'g');
const isOpenTag = (text) => OPEN_TAG_REGEX.test(text.trim());
const isCloseTag = (text) => CLOSE_TAG_REGEX.test(text.trim());
const isComment = (text) => COMMENT_REGEX.test(text.trim());
const isOpenCloseTag = (text) => OPEN_CLOSE_TAG_REGEX.test(text.trim());
const isSelfClosingTag = (text) => SELF_CLOSING_TAG_REGEX.test(text.trim());

class Traverse {
    constructor({ code, enter }) {
        this.code = code;
        this._enter = enter;
    }
    combineLeftJsxNodes(jsxNodes, parent) {
        var _a;
        const start = jsxNodes[0].position.start;
        const end = Object.assign({}, last(jsxNodes).position.end);
        // fix #279
        if (parent && ((_a = parent.position.indent) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            end.offset += parent.position.indent.reduce((acc, indent, index) => acc + (index ? indent + 1 : 0), 0);
        }
        return {
            type: 'jsx',
            data: jsxNodes[0].data,
            value: this.code.slice(start.offset, end.offset),
            position: {
                start,
                end,
            },
        };
    }
    // fix #7
    combineJsxNodes(nodes, parent) {
        let offset = 0;
        let hasOpenTag = false;
        const jsxNodes = [];
        const { length } = nodes;
        // eslint-disable-next-line sonarjs/cognitive-complexity
        return nodes.reduce((acc, node, index) => {
            if (node.type === 'jsx') {
                const value = node.value;
                if (isOpenTag(value)) {
                    offset++;
                    hasOpenTag = true;
                    jsxNodes.push(node);
                }
                else {
                    if (isCloseTag(value)) {
                        offset--;
                        jsxNodes.push(node);
                    }
                    else if (isComment(value) ||
                        isSelfClosingTag(value) ||
                        isOpenCloseTag(value)) {
                        jsxNodes.push(node);
                    }
                    else {
                        // #272, we consider the first jsx node as open tag although it's not precise
                        if (!index) {
                            offset++;
                            hasOpenTag = true;
                        }
                        try {
                            // fix #138
                            jsxNodes.push(...arrayify(parser.normalizeJsxNode(node, parent)));
                        }
                        catch (_a) {
                            // #272 related
                            /* istanbul ignore else */
                            if (offset) {
                                jsxNodes.push(node);
                            }
                            else {
                                // should never happen, just for robustness
                                const { start } = node.position;
                                throw Object.assign(new SyntaxError('unknown jsx node: ' + JSON.stringify(value)), {
                                    lineNumber: start.line,
                                    column: start.column,
                                    index: start.offset,
                                });
                            }
                        }
                    }
                    if (!offset) {
                        // fix #158
                        const firstOpenTagIndex = jsxNodes.findIndex(node => typeof node.value === 'string' && isOpenTag(node.value));
                        if (firstOpenTagIndex === -1) {
                            if (hasOpenTag) {
                                acc.push(this.combineLeftJsxNodes(jsxNodes, parent));
                            }
                            else {
                                acc.push(...jsxNodes);
                            }
                        }
                        else {
                            acc.push(...jsxNodes.slice(0, firstOpenTagIndex), this.combineLeftJsxNodes(jsxNodes.slice(firstOpenTagIndex), parent));
                        }
                        jsxNodes.length = 0;
                    }
                }
            }
            else if (offset) {
                jsxNodes.push(node);
            }
            else {
                acc.push(node);
            }
            if (index === length - 1 && jsxNodes.length > 0) {
                acc.push(this.combineLeftJsxNodes(jsxNodes, parent));
            }
            return acc;
        }, []);
    }
    traverse(node, parent) {
        /* istanbul ignore if */
        if (!node) {
            // should never happen, just for robustness
            return;
        }
        let children = node.children;
        if (children) {
            const parent = node;
            children = node.children = this.combineJsxNodes(children, parent);
            for (const child of children) {
                this.traverse(child, parent);
            }
        }
        this._enter(node, parent);
    }
}
const traverse = (root, options) => new Traverse(options).traverse(root);

const mdProcessor = unified().use(remarkParse).freeze();
const mdxProcessor = mdProcessor().use(remarkMdx).freeze();
const AST_PROPS = ['body', 'comments', 'tokens'];
const ES_NODE_TYPES = ['export', 'import', 'jsx'];
const LOC_ERROR_PROPERTIES = ['column', 'lineNumber'];
const DEFAULT_EXTENSIONS = ['.mdx'];
const MARKDOWN_EXTENSIONS = ['.md'];
const DEFAULT_PARSER_OPTIONS = {
    comment: true,
    ecmaFeatures: {
        jsx: true,
    },
    ecmaVersion: new Date().getUTCFullYear(),
    sourceType: 'module',
    tokens: true,
    filePath: '__placeholder__.mdx',
    // required for @typescript-eslint/parser
    // reference: https://github.com/typescript-eslint/typescript-eslint/pull/2028
    loc: true,
    range: true,
};
const JSX_WRAPPER_START = '<$>';
const JSX_WRAPPER_END = '</$>';
const OFFSET = JSX_WRAPPER_START.length;
class Parser {
    constructor() {
        // @internal
        this._options = DEFAULT_PARSER_OPTIONS;
        this.parse = this.parse.bind(this);
        this.parseForESLint = this.parseForESLint.bind(this);
    }
    normalizeJsxNode(node, parent, options = this._options) {
        const value = node.value;
        if (node.type !== 'jsx' || isComment(value)) {
            return node;
        }
        const commentContent = COMMENT_CONTENT_REGEX.exec(value);
        if (commentContent) {
            const comments = [];
            const { position: { start: { line, column, offset: startOffset }, }, data, } = node;
            Object.assign(node, {
                data: Object.assign(Object.assign({}, data), { jsxType: 'JSXElementWithHTMLComments', comments, 
                    // jsx in paragraph is considered as plain html in mdx, what means html style comments are valid
                    // TODO: in this case, jsx style comments could be a mistake
                    inline: !!parent && parent.type !== 'root' }),
                value: value.replace(COMMENT_CONTENT_REGEX_GLOBAL, (matched, $0, $1, $2, offset) => {
                    const endOffset = offset + matched.length;
                    const startLines = value.slice(0, offset).split('\n');
                    const endLines = value.slice(0, endOffset).split('\n');
                    const fixed = `{/${'*'.repeat($0.length - 2)}${$1}${'*'.repeat($2.length - 2)}/}`;
                    const startLineOffset = startLines.length - 1;
                    const endLineOffset = endLines.length - 1;
                    comments.push({
                        fixed,
                        // ! eslint ast column is 0-indexed, but unified is 1-indexed
                        loc: {
                            start: {
                                line: line + startLineOffset,
                                column: last(startLines).length +
                                    (startLineOffset ? 0 : column - 1),
                                offset: startOffset + offset,
                            },
                            end: {
                                line: line + endLineOffset,
                                column: last(endLines).length + (endLineOffset ? 0 : column - 1),
                                offset: startOffset + endOffset,
                            },
                        },
                        origin: matched,
                    });
                    return fixed;
                }),
            });
        }
        return this._normalizeJsxNodes(node, options);
    }
    parse(code, options) {
        return this.parseForESLint(code, options).ast;
    }
    parseForESLint(code, options) {
        const extname = path.extname(options.filePath);
        const isMdx = DEFAULT_EXTENSIONS.concat(options.extensions || []).includes(extname);
        const isMarkdown = MARKDOWN_EXTENSIONS.concat(options.markdownExtensions || []).includes(extname);
        if (!isMdx && !isMarkdown) {
            return this._eslintParse(code, options);
        }
        const root = (isMdx ? mdxProcessor : mdProcessor).parse(code);
        this._ast = Object.assign(Object.assign({}, normalizePosition(root.position)), { type: 'Program', sourceType: options.sourceType || 'module', body: [], comments: [], tokens: [] });
        this._services = {
            JSXElementsWithHTMLComments: [],
        };
        if (isMdx) {
            traverse(root, {
                code,
                enter: (node, parent) => {
                    if (!ES_NODE_TYPES.includes(node.type)) {
                        return;
                    }
                    for (const normalizedNode of arrayify(this.normalizeJsxNode(node, parent, options))) {
                        this._nodeToAst(code, normalizedNode, options);
                    }
                },
            });
        }
        return {
            ast: this._ast,
            services: this._services,
        };
    }
    // @internal
    _eslintParse(code, options) {
        if (!this._parsers || options.parser !== this._options.parser) {
            this._parsers = normalizeParser(options.parser);
        }
        /* istanbul ignore else */
        if (options.filePath && this._options !== options) {
            Object.assign(this._options, options);
        }
        let program;
        let parseError;
        for (const parser of this._parsers) {
            try {
                program = parser(code, this._options);
                break;
            }
            catch (err) {
                if (!parseError) {
                    parseError = err;
                }
            }
        }
        if (!program && parseError) {
            throw parseError;
        }
        /* istanbul ignore next */
        return ('ast' in program && program.ast
            ? program
            : { ast: program });
    }
    // fix adjacent JSX nodes
    // @internal
    // eslint-disable-next-line sonarjs/cognitive-complexity
    _normalizeJsxNodes(node, options) {
        const value = node.value;
        let program;
        try {
            // wrap into single element which is valid jsx but not valid jsx in mdx, so that it won't break on adjacent JSX nodes
            program = this._eslintParse(`${JSX_WRAPPER_START}${value}${JSX_WRAPPER_END}`, options).ast;
        }
        catch (err) {
            if (hasProperties(err, LOC_ERROR_PROPERTIES)) {
                const { position: { start }, } = node;
                /* istanbul ignore else */
                if ('index' in err) {
                    err.index += start.offset - OFFSET;
                }
                else if ('pos' in err) {
                    err.pos += start.offset - OFFSET;
                }
                err.column =
                    /* istanbul ignore next */
                    err.lineNumber > 1 ? err.column : err.column + start.column - OFFSET;
                err.lineNumber += start.line - 1;
                throw err;
            }
            return node;
        }
        const { expression } = program.body[0];
        if (!isJsxNode(expression) || expression.children.length <= 1) {
            return node;
        }
        const { position: { start: { line, offset }, }, data, } = node;
        return expression.children.reduce((nodes, jsNode) => {
            if (!isJsxNode(jsNode)) {
                return nodes;
            }
            /* istanbul ignore next */
            const { start: nodeStart, end: nodeEnd, loc: { start, end } = {
                start: { column: nodeStart, line: 1 },
                end: { column: nodeEnd, line: 1 },
            }, range = [nodeStart, nodeEnd], } = jsNode;
            const startLine = line + start.line - 1;
            const endLine = line + end.line - 1;
            const startOffset = range[0] - OFFSET;
            const endOffset = range[1] - OFFSET;
            nodes.push({
                type: 'jsx',
                data: nodes.length > 0 ? null : data,
                value: value.slice(startOffset, endOffset),
                position: {
                    start: {
                        line: startLine,
                        column: line === startLine ? start.column - OFFSET : start.column,
                        offset: offset + startOffset,
                    },
                    end: {
                        line: endLine,
                        column: line === startLine ? end.column - OFFSET : end.column,
                        offset: offset + endOffset,
                    },
                },
            });
            return nodes;
        }, []);
    }
    // @internal
    _nodeToAst(code, node, options) {
        if (node.data && node.data.jsxType === 'JSXElementWithHTMLComments') {
            this._services.JSXElementsWithHTMLComments.push(node);
        }
        const value = node.value;
        const { loc, start, end } = normalizePosition(node.position);
        // fix #4
        if (isComment(value)) {
            const comment = COMMENT_CONTENT_REGEX.exec(value)[2];
            this._ast.comments.push({
                type: 'Block',
                value: comment,
                loc,
                range: [start, end],
            });
            return;
        }
        const startLine = loc.start.line - 1; // ! line is 1-indexed, change to 0-indexed to simplify usage
        let program;
        try {
            program = this._eslintParse(value, options).ast;
        }
        catch (e) {
            /* istanbul ignore if */
            if (hasProperties(e, LOC_ERROR_PROPERTIES)) {
                // should be handled by `_normalizeJsxNodes`, just for robustness
                e.index += start;
                e.column = e.lineNumber > 1 ? e.column : e.column + loc.start.column;
                e.lineNumber += startLine;
            }
            throw e;
        }
        const startPoint = {
            line: startLine,
            // #279 related
            column: getPositionAt(code, start).column,
            offset: start,
        };
        for (const prop of AST_PROPS)
            this._ast[prop].push(
            // ts doesn't understand the mixed type
            ...program[prop].map((item) => restoreNodeLocation(item, startPoint)));
    }
}
const parser = new Parser();
// eslint-disable-next-line @typescript-eslint/unbound-method
const { parse, parseForESLint } = parser;

export { AST_PROPS, CLOSE_TAG_REGEX, COMMENT_CONTENT_REGEX, COMMENT_CONTENT_REGEX_GLOBAL, COMMENT_REGEX, DEFAULT_EXTENSIONS, DEFAULT_PARSER_OPTIONS, ES_NODE_TYPES, FALLBACK_PARSERS, JSX_TYPES, LOC_ERROR_PROPERTIES, MARKDOWN_EXTENSIONS, OPEN_CLOSE_TAG_REGEX, OPEN_TAG_REGEX, Parser, SELF_CLOSING_TAG_REGEX, Traverse, arrayify, closeTag, comment, commentClose, commentContent, commentOpen, first, getPositionAt, hasProperties, isCloseTag, isComment, isJsxNode, isOpenCloseTag, isOpenTag, isSelfClosingTag, last, mdProcessor, mdxProcessor, normalizeParser, normalizePosition, openTag, parse, parseForESLint, parser, restoreNodeLocation, selfClosingTag, traverse };
