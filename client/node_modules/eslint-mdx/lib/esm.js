import { __assign, __spreadArray } from 'tslib';
import path from 'path';
import remarkMdx from 'remark-mdx';
import remarkParse from 'remark-parse';
import unified from 'unified';

/// <reference path="../typings.d.ts" />
var FALLBACK_PARSERS = [
    '@typescript-eslint/parser',
    '@babel/eslint-parser',
    'babel-eslint',
    'espree',
];
var JSX_TYPES = ['JSXElement', 'JSXFragment'];
var isJsxNode = function (node) {
    return JSX_TYPES.includes(node.type);
};
// eslint-disable-next-line sonarjs/cognitive-complexity
var normalizeParser = function (parser) {
    if (parser) {
        if (typeof parser === 'string') {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            parser = require(parser);
        }
        if (typeof parser === 'object') {
            parser =
                ('parseForESLint' in parser && parser.parseForESLint) ||
                    ('parse' in parser && parser.parse);
        }
        if (typeof parser !== 'function') {
            throw new TypeError("Invalid custom parser for `eslint-mdx`: " + parser);
        }
        return [parser];
    }
    var parsers = [];
    // try to load FALLBACK_PARSERS automatically
    for (var _i = 0, FALLBACK_PARSERS_1 = FALLBACK_PARSERS; _i < FALLBACK_PARSERS_1.length; _i++) {
        var fallback = FALLBACK_PARSERS_1[_i];
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            var fallbackParser = require(fallback);
            /* istanbul ignore next */
            var parserFn = 'parseForESLint' in fallbackParser
                ? // eslint-disable-next-line @typescript-eslint/unbound-method
                    fallbackParser.parseForESLint
                : // eslint-disable-next-line @typescript-eslint/unbound-method
                    fallbackParser.parse;
            /* istanbul ignore else */
            if (parserFn) {
                parsers.push(parserFn);
            }
        }
        catch (_a) { }
    }
    return parsers;
};
var normalizePosition = function (loc) {
    var start = loc.start.offset;
    var end = loc.end.offset;
    return {
        range: [start, end],
        loc: loc,
        start: start,
        end: end,
    };
};
var hasProperties = function (obj, properties) {
    return typeof obj === 'object' &&
        obj &&
        properties.every(function (property) { return property in obj; });
};
// fix #292
var getPositionAt = function (code, offset) {
    var currOffset = 0;
    var lines = code.split('\n');
    // eslint-disable-next-line unicorn/no-for-loop
    for (var index = 0; index < lines.length; index++) {
        var line = index + 1;
        var nextOffset = currOffset + lines[index].length;
        if (nextOffset >= offset) {
            return {
                line: line,
                column: offset - currOffset,
            };
        }
        currOffset = nextOffset + 1; // add a line break `\n` offset
    }
};
var restoreNodeLocation = function (node, point) {
    if (node && typeof node === 'object') {
        for (var _i = 0, _a = Object.values(node); _i < _a.length; _i++) {
            var value = _a[_i];
            restoreNodeLocation(value, point);
        }
    }
    if (!hasProperties(node, ['loc', 'range'])) {
        return node;
    }
    var _b = node.loc, startLoc = _b.start, endLoc = _b.end, _c = node.range, start = _c[0], end = _c[1];
    var range = [(start += point.offset), (end += point.offset)];
    return Object.assign(node, {
        start: start,
        end: end,
        range: range,
        loc: {
            start: {
                line: point.line + startLoc.line,
                column: startLoc.column + (startLoc.line === 1 ? point.column : 0),
            },
            end: {
                line: point.line + endLoc.line,
                column: endLoc.column + (endLoc.line === 1 ? point.column : 0),
            },
        },
    });
};
var arrayify = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.reduce(function (arr, curr) {
        arr.push.apply(arr, (Array.isArray(curr) ? curr : curr == null ? [] : [curr]));
        return arr;
    }, []);
};
var first = function (items) { return items && items[0]; };
var last = function (items) {
    return items && items[items.length - 1];
};

// based on https://github.com/mdx-js/mdx/blob/master/packages/remark-mdx/tag.js
var dotAllPolyfill = '[\0-\uFFFF]';
var attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var unquoted = '[^"\'=<>`\\u0000-\\u0020]+';
var singleQuoted = "'[^']*'";
var doubleQuoted = '"[^"]*"';
var jsProps = '{.*}'.replace('.', dotAllPolyfill);
var attributeValue = '(?:' +
    unquoted +
    '|' +
    singleQuoted +
    '|' +
    doubleQuoted +
    '|' +
    jsProps +
    ')';
var attribute = '(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)';
var openTag = '<[A-Za-z]*[A-Za-z0-9\\.\\-]*' + attribute + '*\\s*>';
var closeTag = '<\\s*\\/[A-Za-z]*[A-Za-z0-9\\.\\-]*\\s*>';
var selfClosingTag = '<[A-Za-z]*[A-Za-z0-9\\.\\-]*' + attribute + '*\\s*\\/?>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var commentOpen = '(<!---*)';
var commentClose = '(-*-->)';
var commentContent = commentOpen + "([\\s\\S]*?)" + commentClose;
var OPEN_TAG_REGEX = new RegExp("^(?:" + openTag + ")$");
var CLOSE_TAG_REGEX = new RegExp("^(?:" + closeTag + ")$");
var OPEN_CLOSE_TAG_REGEX = new RegExp("^(?:" + (openTag + '[^<]*' + closeTag) + ")$");
var SELF_CLOSING_TAG_REGEX = new RegExp("^(?:" + selfClosingTag + ")$");
var COMMENT_REGEX = new RegExp("^(?:" + comment + ")$");
var COMMENT_CONTENT_REGEX = new RegExp(commentContent);
var COMMENT_CONTENT_REGEX_GLOBAL = new RegExp(commentContent, 'g');
var isOpenTag = function (text) { return OPEN_TAG_REGEX.test(text.trim()); };
var isCloseTag = function (text) { return CLOSE_TAG_REGEX.test(text.trim()); };
var isComment = function (text) { return COMMENT_REGEX.test(text.trim()); };
var isOpenCloseTag = function (text) {
    return OPEN_CLOSE_TAG_REGEX.test(text.trim());
};
var isSelfClosingTag = function (text) {
    return SELF_CLOSING_TAG_REGEX.test(text.trim());
};

var Traverse = /** @class */ (function () {
    function Traverse(_a) {
        var code = _a.code, enter = _a.enter;
        this.code = code;
        this._enter = enter;
    }
    Traverse.prototype.combineLeftJsxNodes = function (jsxNodes, parent) {
        var _a;
        var start = jsxNodes[0].position.start;
        var end = __assign({}, last(jsxNodes).position.end);
        // fix #279
        if (parent && ((_a = parent.position.indent) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            end.offset += parent.position.indent.reduce(function (acc, indent, index) { return acc + (index ? indent + 1 : 0); }, 0);
        }
        return {
            type: 'jsx',
            data: jsxNodes[0].data,
            value: this.code.slice(start.offset, end.offset),
            position: {
                start: start,
                end: end,
            },
        };
    };
    // fix #7
    Traverse.prototype.combineJsxNodes = function (nodes, parent) {
        var _this = this;
        var offset = 0;
        var hasOpenTag = false;
        var jsxNodes = [];
        var length = nodes.length;
        // eslint-disable-next-line sonarjs/cognitive-complexity
        return nodes.reduce(function (acc, node, index) {
            if (node.type === 'jsx') {
                var value = node.value;
                if (isOpenTag(value)) {
                    offset++;
                    hasOpenTag = true;
                    jsxNodes.push(node);
                }
                else {
                    if (isCloseTag(value)) {
                        offset--;
                        jsxNodes.push(node);
                    }
                    else if (isComment(value) ||
                        isSelfClosingTag(value) ||
                        isOpenCloseTag(value)) {
                        jsxNodes.push(node);
                    }
                    else {
                        // #272, we consider the first jsx node as open tag although it's not precise
                        if (!index) {
                            offset++;
                            hasOpenTag = true;
                        }
                        try {
                            // fix #138
                            jsxNodes.push.apply(jsxNodes, arrayify(parser.normalizeJsxNode(node, parent)));
                        }
                        catch (_a) {
                            // #272 related
                            /* istanbul ignore else */
                            if (offset) {
                                jsxNodes.push(node);
                            }
                            else {
                                // should never happen, just for robustness
                                var start = node.position.start;
                                throw Object.assign(new SyntaxError('unknown jsx node: ' + JSON.stringify(value)), {
                                    lineNumber: start.line,
                                    column: start.column,
                                    index: start.offset,
                                });
                            }
                        }
                    }
                    if (!offset) {
                        // fix #158
                        var firstOpenTagIndex = jsxNodes.findIndex(function (node) { return typeof node.value === 'string' && isOpenTag(node.value); });
                        if (firstOpenTagIndex === -1) {
                            if (hasOpenTag) {
                                acc.push(_this.combineLeftJsxNodes(jsxNodes, parent));
                            }
                            else {
                                acc.push.apply(acc, jsxNodes);
                            }
                        }
                        else {
                            acc.push.apply(acc, __spreadArray(__spreadArray([], jsxNodes.slice(0, firstOpenTagIndex)), [_this.combineLeftJsxNodes(jsxNodes.slice(firstOpenTagIndex), parent)]));
                        }
                        jsxNodes.length = 0;
                    }
                }
            }
            else if (offset) {
                jsxNodes.push(node);
            }
            else {
                acc.push(node);
            }
            if (index === length - 1 && jsxNodes.length > 0) {
                acc.push(_this.combineLeftJsxNodes(jsxNodes, parent));
            }
            return acc;
        }, []);
    };
    Traverse.prototype.traverse = function (node, parent) {
        /* istanbul ignore if */
        if (!node) {
            // should never happen, just for robustness
            return;
        }
        var children = node.children;
        if (children) {
            var parent_1 = node;
            children = node.children = this.combineJsxNodes(children, parent_1);
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var child = children_1[_i];
                this.traverse(child, parent_1);
            }
        }
        this._enter(node, parent);
    };
    return Traverse;
}());
var traverse = function (root, options) {
    return new Traverse(options).traverse(root);
};

var mdProcessor = unified().use(remarkParse).freeze();
var mdxProcessor = mdProcessor().use(remarkMdx).freeze();
var AST_PROPS = ['body', 'comments', 'tokens'];
var ES_NODE_TYPES = ['export', 'import', 'jsx'];
var LOC_ERROR_PROPERTIES = ['column', 'lineNumber'];
var DEFAULT_EXTENSIONS = ['.mdx'];
var MARKDOWN_EXTENSIONS = ['.md'];
var DEFAULT_PARSER_OPTIONS = {
    comment: true,
    ecmaFeatures: {
        jsx: true,
    },
    ecmaVersion: new Date().getUTCFullYear(),
    sourceType: 'module',
    tokens: true,
    filePath: '__placeholder__.mdx',
    // required for @typescript-eslint/parser
    // reference: https://github.com/typescript-eslint/typescript-eslint/pull/2028
    loc: true,
    range: true,
};
var JSX_WRAPPER_START = '<$>';
var JSX_WRAPPER_END = '</$>';
var OFFSET = JSX_WRAPPER_START.length;
var Parser = /** @class */ (function () {
    function Parser() {
        // @internal
        this._options = DEFAULT_PARSER_OPTIONS;
        this.parse = this.parse.bind(this);
        this.parseForESLint = this.parseForESLint.bind(this);
    }
    Parser.prototype.normalizeJsxNode = function (node, parent, options) {
        if (options === void 0) { options = this._options; }
        var value = node.value;
        if (node.type !== 'jsx' || isComment(value)) {
            return node;
        }
        var commentContent = COMMENT_CONTENT_REGEX.exec(value);
        if (commentContent) {
            var comments_1 = [];
            var _a = node.position.start, line_1 = _a.line, column_1 = _a.column, startOffset_1 = _a.offset, data = node.data;
            Object.assign(node, {
                data: __assign(__assign({}, data), { jsxType: 'JSXElementWithHTMLComments', comments: comments_1, 
                    // jsx in paragraph is considered as plain html in mdx, what means html style comments are valid
                    // TODO: in this case, jsx style comments could be a mistake
                    inline: !!parent && parent.type !== 'root' }),
                value: value.replace(COMMENT_CONTENT_REGEX_GLOBAL, function (matched, $0, $1, $2, offset) {
                    var endOffset = offset + matched.length;
                    var startLines = value.slice(0, offset).split('\n');
                    var endLines = value.slice(0, endOffset).split('\n');
                    var fixed = "{/" + '*'.repeat($0.length - 2) + $1 + '*'.repeat($2.length - 2) + "/}";
                    var startLineOffset = startLines.length - 1;
                    var endLineOffset = endLines.length - 1;
                    comments_1.push({
                        fixed: fixed,
                        // ! eslint ast column is 0-indexed, but unified is 1-indexed
                        loc: {
                            start: {
                                line: line_1 + startLineOffset,
                                column: last(startLines).length +
                                    (startLineOffset ? 0 : column_1 - 1),
                                offset: startOffset_1 + offset,
                            },
                            end: {
                                line: line_1 + endLineOffset,
                                column: last(endLines).length + (endLineOffset ? 0 : column_1 - 1),
                                offset: startOffset_1 + endOffset,
                            },
                        },
                        origin: matched,
                    });
                    return fixed;
                }),
            });
        }
        return this._normalizeJsxNodes(node, options);
    };
    Parser.prototype.parse = function (code, options) {
        return this.parseForESLint(code, options).ast;
    };
    Parser.prototype.parseForESLint = function (code, options) {
        var _this = this;
        var extname = path.extname(options.filePath);
        var isMdx = DEFAULT_EXTENSIONS.concat(options.extensions || []).includes(extname);
        var isMarkdown = MARKDOWN_EXTENSIONS.concat(options.markdownExtensions || []).includes(extname);
        if (!isMdx && !isMarkdown) {
            return this._eslintParse(code, options);
        }
        var root = (isMdx ? mdxProcessor : mdProcessor).parse(code);
        this._ast = __assign(__assign({}, normalizePosition(root.position)), { type: 'Program', sourceType: options.sourceType || 'module', body: [], comments: [], tokens: [] });
        this._services = {
            JSXElementsWithHTMLComments: [],
        };
        if (isMdx) {
            traverse(root, {
                code: code,
                enter: function (node, parent) {
                    if (!ES_NODE_TYPES.includes(node.type)) {
                        return;
                    }
                    for (var _i = 0, _a = arrayify(_this.normalizeJsxNode(node, parent, options)); _i < _a.length; _i++) {
                        var normalizedNode = _a[_i];
                        _this._nodeToAst(code, normalizedNode, options);
                    }
                },
            });
        }
        return {
            ast: this._ast,
            services: this._services,
        };
    };
    // @internal
    Parser.prototype._eslintParse = function (code, options) {
        if (!this._parsers || options.parser !== this._options.parser) {
            this._parsers = normalizeParser(options.parser);
        }
        /* istanbul ignore else */
        if (options.filePath && this._options !== options) {
            Object.assign(this._options, options);
        }
        var program;
        var parseError;
        for (var _i = 0, _a = this._parsers; _i < _a.length; _i++) {
            var parser_1 = _a[_i];
            try {
                program = parser_1(code, this._options);
                break;
            }
            catch (err) {
                if (!parseError) {
                    parseError = err;
                }
            }
        }
        if (!program && parseError) {
            throw parseError;
        }
        /* istanbul ignore next */
        return ('ast' in program && program.ast
            ? program
            : { ast: program });
    };
    // fix adjacent JSX nodes
    // @internal
    // eslint-disable-next-line sonarjs/cognitive-complexity
    Parser.prototype._normalizeJsxNodes = function (node, options) {
        var value = node.value;
        var program;
        try {
            // wrap into single element which is valid jsx but not valid jsx in mdx, so that it won't break on adjacent JSX nodes
            program = this._eslintParse("" + JSX_WRAPPER_START + value + JSX_WRAPPER_END, options).ast;
        }
        catch (err) {
            if (hasProperties(err, LOC_ERROR_PROPERTIES)) {
                var start = node.position.start;
                /* istanbul ignore else */
                if ('index' in err) {
                    err.index += start.offset - OFFSET;
                }
                else if ('pos' in err) {
                    err.pos += start.offset - OFFSET;
                }
                err.column =
                    /* istanbul ignore next */
                    err.lineNumber > 1 ? err.column : err.column + start.column - OFFSET;
                err.lineNumber += start.line - 1;
                throw err;
            }
            return node;
        }
        var expression = program.body[0].expression;
        if (!isJsxNode(expression) || expression.children.length <= 1) {
            return node;
        }
        var _a = node.position.start, line = _a.line, offset = _a.offset, data = node.data;
        return expression.children.reduce(function (nodes, jsNode) {
            if (!isJsxNode(jsNode)) {
                return nodes;
            }
            /* istanbul ignore next */
            var nodeStart = jsNode.start, nodeEnd = jsNode.end, _a = jsNode.loc, _b = _a === void 0 ? {
                start: { column: nodeStart, line: 1 },
                end: { column: nodeEnd, line: 1 },
            } : _a, start = _b.start, end = _b.end, _c = jsNode.range, range = _c === void 0 ? [nodeStart, nodeEnd] : _c;
            var startLine = line + start.line - 1;
            var endLine = line + end.line - 1;
            var startOffset = range[0] - OFFSET;
            var endOffset = range[1] - OFFSET;
            nodes.push({
                type: 'jsx',
                data: nodes.length > 0 ? null : data,
                value: value.slice(startOffset, endOffset),
                position: {
                    start: {
                        line: startLine,
                        column: line === startLine ? start.column - OFFSET : start.column,
                        offset: offset + startOffset,
                    },
                    end: {
                        line: endLine,
                        column: line === startLine ? end.column - OFFSET : end.column,
                        offset: offset + endOffset,
                    },
                },
            });
            return nodes;
        }, []);
    };
    // @internal
    Parser.prototype._nodeToAst = function (code, node, options) {
        var _a;
        if (node.data && node.data.jsxType === 'JSXElementWithHTMLComments') {
            this._services.JSXElementsWithHTMLComments.push(node);
        }
        var value = node.value;
        var _b = normalizePosition(node.position), loc = _b.loc, start = _b.start, end = _b.end;
        // fix #4
        if (isComment(value)) {
            var comment = COMMENT_CONTENT_REGEX.exec(value)[2];
            this._ast.comments.push({
                type: 'Block',
                value: comment,
                loc: loc,
                range: [start, end],
            });
            return;
        }
        var startLine = loc.start.line - 1; // ! line is 1-indexed, change to 0-indexed to simplify usage
        var program;
        try {
            program = this._eslintParse(value, options).ast;
        }
        catch (e) {
            /* istanbul ignore if */
            if (hasProperties(e, LOC_ERROR_PROPERTIES)) {
                // should be handled by `_normalizeJsxNodes`, just for robustness
                e.index += start;
                e.column = e.lineNumber > 1 ? e.column : e.column + loc.start.column;
                e.lineNumber += startLine;
            }
            throw e;
        }
        var startPoint = {
            line: startLine,
            // #279 related
            column: getPositionAt(code, start).column,
            offset: start,
        };
        for (var _i = 0, AST_PROPS_1 = AST_PROPS; _i < AST_PROPS_1.length; _i++) {
            var prop = AST_PROPS_1[_i];
            (_a = this._ast[prop]).push.apply(_a, program[prop].map(function (item) {
                return restoreNodeLocation(item, startPoint);
            }));
        }
    };
    return Parser;
}());
var parser = new Parser();
// eslint-disable-next-line @typescript-eslint/unbound-method
var parse = parser.parse, parseForESLint = parser.parseForESLint;

export { AST_PROPS, CLOSE_TAG_REGEX, COMMENT_CONTENT_REGEX, COMMENT_CONTENT_REGEX_GLOBAL, COMMENT_REGEX, DEFAULT_EXTENSIONS, DEFAULT_PARSER_OPTIONS, ES_NODE_TYPES, FALLBACK_PARSERS, JSX_TYPES, LOC_ERROR_PROPERTIES, MARKDOWN_EXTENSIONS, OPEN_CLOSE_TAG_REGEX, OPEN_TAG_REGEX, Parser, SELF_CLOSING_TAG_REGEX, Traverse, arrayify, closeTag, comment, commentClose, commentContent, commentOpen, first, getPositionAt, hasProperties, isCloseTag, isComment, isJsxNode, isOpenCloseTag, isOpenTag, isSelfClosingTag, last, mdProcessor, mdxProcessor, normalizeParser, normalizePosition, openTag, parse, parseForESLint, parser, restoreNodeLocation, selfClosingTag, traverse };
