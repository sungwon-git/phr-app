import { __awaiter } from 'tslib';
import { execSync } from 'child_process';
import { tmpdir as tmpdir$1 } from 'os';
import path from 'path';
import fs from 'fs';
import { v4 } from 'uuid';

/**
 * @link https://github.com/sindresorhus/temp-dir/blob/main/index.js#L9
 */
const tmpdir = fs.realpathSync(tmpdir$1());
let tsconfigPathsAvailable;
const isTsconfigPathsAvailable = () => {
    if (typeof tsconfigPathsAvailable === 'boolean') {
        return tsconfigPathsAvailable;
    }
    try {
        // eslint-disable-next-line node/no-extraneous-require
        tsconfigPathsAvailable = !!require.resolve('tsconfig-paths');
    }
    catch (_a) {
        /**
         * `require.resolve` can not be mocked to fail
         * @link https://github.com/facebook/jest/issues/9543
         */
        /* istanbul ignore next */
        tsconfigPathsAvailable = false;
    }
    return tsconfigPathsAvailable;
};
const syncFnCache = new Map();
function createSyncFn(workerPath) {
    if (!path.isAbsolute(workerPath)) {
        throw new Error('`workerPath` must be absolute');
    }
    const cachedSyncFn = syncFnCache.get(workerPath);
    if (cachedSyncFn) {
        return cachedSyncFn;
    }
    let resolvedWorkerPath = workerPath;
    if (!resolvedWorkerPath.endsWith('.ts')) {
        resolvedWorkerPath = require.resolve(workerPath);
    }
    const executor = resolvedWorkerPath.endsWith('.ts')
        ? 'ts-node' +
            (isTsconfigPathsAvailable()
                ? ' -r tsconfig-paths/register'
                : /* istanbul ignore next */ '')
        : 'node';
    const syncFn = (...args) => {
        const filename = path.resolve(tmpdir, `synckit-${v4()}.json`);
        fs.writeFileSync(filename, JSON.stringify(args));
        const command = `${executor} ${resolvedWorkerPath} ${filename}`;
        try {
            execSync(command, {
                stdio: 'inherit',
            });
            const result = fs.readFileSync(filename, 'utf8');
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return JSON.parse(result);
        }
        finally {
            fs.unlinkSync(filename);
        }
    };
    syncFnCache.set(workerPath, syncFn);
    return syncFn;
}
const runAsWorker = (fn) => __awaiter(void 0, void 0, void 0, function* () {
    const filename = process.argv[2];
    const content = fs.readFileSync(filename, 'utf-8');
    const options = JSON.parse(content);
    fs.writeFileSync(filename, JSON.stringify(yield fn(...options)));
});

export { createSyncFn, runAsWorker, tmpdir };
