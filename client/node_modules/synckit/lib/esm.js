import { __awaiter, __generator } from 'tslib';
import { execSync } from 'child_process';
import { tmpdir as tmpdir$1 } from 'os';
import path from 'path';
import fs from 'fs';
import { v4 } from 'uuid';

/**
 * @link https://github.com/sindresorhus/temp-dir/blob/main/index.js#L9
 */
var tmpdir = fs.realpathSync(tmpdir$1());
var tsconfigPathsAvailable;
var isTsconfigPathsAvailable = function () {
    if (typeof tsconfigPathsAvailable === 'boolean') {
        return tsconfigPathsAvailable;
    }
    try {
        // eslint-disable-next-line node/no-extraneous-require
        tsconfigPathsAvailable = !!require.resolve('tsconfig-paths');
    }
    catch (_a) {
        /**
         * `require.resolve` can not be mocked to fail
         * @link https://github.com/facebook/jest/issues/9543
         */
        /* istanbul ignore next */
        tsconfigPathsAvailable = false;
    }
    return tsconfigPathsAvailable;
};
var syncFnCache = new Map();
function createSyncFn(workerPath) {
    if (!path.isAbsolute(workerPath)) {
        throw new Error('`workerPath` must be absolute');
    }
    var cachedSyncFn = syncFnCache.get(workerPath);
    if (cachedSyncFn) {
        return cachedSyncFn;
    }
    var resolvedWorkerPath = workerPath;
    if (!resolvedWorkerPath.endsWith('.ts')) {
        resolvedWorkerPath = require.resolve(workerPath);
    }
    var executor = resolvedWorkerPath.endsWith('.ts')
        ? 'ts-node' +
            (isTsconfigPathsAvailable()
                ? ' -r tsconfig-paths/register'
                : /* istanbul ignore next */ '')
        : 'node';
    var syncFn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var filename = path.resolve(tmpdir, "synckit-" + v4() + ".json");
        fs.writeFileSync(filename, JSON.stringify(args));
        var command = executor + " " + resolvedWorkerPath + " " + filename;
        try {
            execSync(command, {
                stdio: 'inherit',
            });
            var result = fs.readFileSync(filename, 'utf8');
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return JSON.parse(result);
        }
        finally {
            fs.unlinkSync(filename);
        }
    };
    syncFnCache.set(workerPath, syncFn);
    return syncFn;
}
var runAsWorker = function (fn) { return __awaiter(void 0, void 0, void 0, function () {
    var filename, content, options, _a, _b, _c, _d, _e;
    return __generator(this, function (_f) {
        switch (_f.label) {
            case 0:
                filename = process.argv[2];
                content = fs.readFileSync(filename, 'utf-8');
                options = JSON.parse(content);
                _b = (_a = fs).writeFileSync;
                _c = [filename];
                _e = (_d = JSON).stringify;
                return [4 /*yield*/, fn.apply(void 0, options)];
            case 1:
                _b.apply(_a, _c.concat([_e.apply(_d, [_f.sent()])]));
                return [2 /*return*/];
        }
    });
}); };

export { createSyncFn, runAsWorker, tmpdir };
